import { getOpenApiDocumentFromUrl, isAllowedLocalSchemaUrl, validate } from '@mintlify/common';
import * as previewing from '@mintlify/previewing';
import { mockProcessExit } from 'vitest-mock-process';

import { readLocalOpenApiFile } from '../src/helpers.js';
import { mockValidOpenApiDocument, runCommand } from './utils.js';

vi.mock('@mintlify/common', () => ({
  getOpenApiDocumentFromUrl: vi.fn(),
  isAllowedLocalSchemaUrl: vi.fn(),
  validate: vi.fn(),
}));

vi.mock('../src/helpers.js', async () => {
  const originalModule = await import('../src/helpers.js');
  return {
    ...originalModule,
    readLocalOpenApiFile: vi.fn(),
  };
});

const addLogSpy = vi.spyOn(previewing, 'addLog');
const processExitMock = mockProcessExit();

describe('openApiCheck', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('valid openApi file from url', async () => {
    vi.mocked(isAllowedLocalSchemaUrl).mockReturnValueOnce(true);
    vi.mocked(getOpenApiDocumentFromUrl).mockResolvedValueOnce(mockValidOpenApiDocument);

    await runCommand('openapi-check', 'https://petstore3.swagger.io/api/v3/openapi.json');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'OpenAPI definition is valid.' },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(0);
  });

  it('invalid openApi file from url', async () => {
    vi.mocked(isAllowedLocalSchemaUrl).mockReturnValueOnce(true);
    vi.mocked(getOpenApiDocumentFromUrl).mockRejectedValueOnce(
      new Error('Could not parse OpenAPI document.')
    );

    await runCommand('openapi-check', 'https://petstore3.swagger.io/api/v3/openapi.json');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'Could not parse OpenAPI document.' },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(1);
  });

  it('valid openApi file from localhost', async () => {
    vi.mocked(isAllowedLocalSchemaUrl).mockReturnValueOnce(true);
    vi.mocked(getOpenApiDocumentFromUrl).mockResolvedValueOnce(mockValidOpenApiDocument);

    await runCommand('openapi-check', 'http://localhost:3000/openapi.json');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'OpenAPI definition is valid.' },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(0);
  });

  it('invalid openApi file from localhost', async () => {
    vi.mocked(isAllowedLocalSchemaUrl).mockReturnValueOnce(false);
    vi.mocked(readLocalOpenApiFile).mockResolvedValueOnce(undefined);

    await runCommand('openapi-check', 'http://localhost:3000/openapi.json');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: {
          message:
            'failed to parse OpenAPI spec: could not parse file correctly, please check for any syntax errors.',
        },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(1);
  });

  it('valid openApi file from local file', async () => {
    vi.mocked(isAllowedLocalSchemaUrl).mockReturnValueOnce(false);
    vi.mocked(readLocalOpenApiFile).mockResolvedValueOnce(mockValidOpenApiDocument);
    vi.mocked(validate).mockResolvedValueOnce({
      valid: true,
      errors: [],
    });

    await runCommand('openapi-check', 'test/openapi.yaml');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'OpenAPI definition is valid.' },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(0);
  });

  it('invalid openApi file from local file', async () => {
    vi.mocked(isAllowedLocalSchemaUrl).mockReturnValueOnce(false);
    vi.mocked(readLocalOpenApiFile).mockResolvedValueOnce(mockValidOpenApiDocument);
    vi.mocked(validate).mockRejectedValueOnce(new Error('some schema parsing error'));

    await runCommand('openapi-check', 'test/openapi.yaml');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'some schema parsing error' },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(1);
  });
});
