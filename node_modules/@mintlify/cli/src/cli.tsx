import { validate, getOpenApiDocumentFromUrl, isAllowedLocalSchemaUrl } from '@mintlify/common';
import { getBrokenInternalLinks, renameFilesAndUpdateLinksInContent } from '@mintlify/link-rot';
import {
  addLog,
  dev,
  ErrorLog,
  SpinnerLog,
  SuccessLog,
  Logs,
  clearLogs,
  BrokenLinksLog,
  WarningLog,
} from '@mintlify/previewing';
import { render, Text } from 'ink';
import path from 'path';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

import {
  checkPort,
  checkForMintJson,
  checkNodeVersion,
  upgradeConfig,
  checkForDocsJson,
  getVersions,
  suppressConsoleWarnings,
  terminate,
  readLocalOpenApiFile,
} from './helpers.js';
import { migrateMdx } from './migrateMdx.js';
import { update } from './update.js';

export const cli = ({ packageName = 'mint' }: { packageName?: string }) => {
  render(<Logs />);

  return (
    yargs(hideBin(process.argv))
      .scriptName(packageName)
      .middleware(checkNodeVersion)
      .middleware(suppressConsoleWarnings)
      .command(
        'dev',
        'initialize a local preview environment',
        (yargs) =>
          yargs
            .option('open', {
              type: 'boolean',
              default: true,
              description: 'open a local preview in the browser',
            })
            .option('local-schema', {
              type: 'boolean',
              default: false,
              hidden: true,
              description:
                'use a locally hosted schema file (note: only https protocol is supported in production)',
            })
            .option('client-version', {
              type: 'string',
              hidden: true,
              description: 'the version of the client to use for cli testing',
            })
            .option('groups', {
              type: 'array',
              description: 'Mock user groups for local development and testing',
              example: '--groups admin user',
            })
            .usage('usage: mintlify dev [options]')
            .example('mintlify dev', 'run with default settings (opens in browser)')
            .example('mintlify dev --no-open', 'run without opening in browser'),
        async (argv) => {
          const port = await checkPort(argv);
          const { cli: cliVersion } = getVersions();
          if (port != undefined) {
            await dev({
              ...argv,
              port,
              packageName,
              cliVersion,
            });
          } else {
            addLog(<ErrorLog message="no available port found" />);
            await terminate(1);
          }
        }
      )
      .command(
        'openapi-check <filename>',
        'check if an OpenAPI spec is valid',
        (yargs) =>
          yargs
            .positional('filename', {
              describe:
                'the filename of the OpenAPI spec (e.g. ./openapi.yaml) or the URL to the OpenAPI spec (e.g. https://petstore3.swagger.io/api/v3/openapi.json)',
              type: 'string',
              demandOption: true,
            })
            .option('local-schema', {
              type: 'boolean',
              default: false,
              description:
                'use a locally hosted schema file (note: only https protocol is supported in production)',
            }),
        async ({ filename, 'local-schema': localSchema }) => {
          try {
            if (isAllowedLocalSchemaUrl(filename, localSchema)) {
              await getOpenApiDocumentFromUrl(filename);
              addLog(<SuccessLog message="OpenAPI definition is valid." />);
              await terminate(0);
            }

            if (filename.startsWith('http://') && !localSchema) {
              addLog(
                <WarningLog message="include the --local-schema flag to check locally hosted OpenAPI files" />
              );
              addLog(<WarningLog message="only https protocol is supported in production" />);
              await terminate(0);
            }

            const document = await readLocalOpenApiFile(filename);

            if (!document) {
              throw new Error(
                'failed to parse OpenAPI spec: could not parse file correctly, please check for any syntax errors.'
              );
            }
            await validate(document);
            addLog(<SuccessLog message="OpenAPI definition is valid." />);
          } catch (err) {
            if (err && typeof err === 'object' && 'code' in err && err.code === 'ENOENT') {
              addLog(
                <ErrorLog message={`file not found, please check the path provided: ${filename}`} />
              );
            } else {
              addLog(<ErrorLog message={err instanceof Error ? err.message : 'unknown error'} />);
            }
            await terminate(1);
          }

          await terminate(0);
        }
      )
      .command(
        'broken-links',
        'check for invalid internal links',
        () => undefined,
        async () => {
          const hasMintJson = await checkForMintJson();
          if (!hasMintJson) {
            await checkForDocsJson();
          }

          addLog(<SpinnerLog message="checking for broken links..." />);
          try {
            const brokenLinks = await getBrokenInternalLinks();
            if (brokenLinks.length === 0) {
              clearLogs();
              addLog(<SuccessLog message="no broken links found" />);
              await terminate(0);
            }

            const brokenLinksByFile: Record<string, string[]> = {};
            brokenLinks.forEach((mdxPath) => {
              const filename = path.join(mdxPath.relativeDir, mdxPath.filename);
              const brokenLinksForFile = brokenLinksByFile[filename];
              if (brokenLinksForFile) {
                brokenLinksForFile.push(mdxPath.originalPath);
              } else {
                brokenLinksByFile[filename] = [mdxPath.originalPath];
              }
            });
            clearLogs();
            addLog(<BrokenLinksLog brokenLinksByFile={brokenLinksByFile} />);
          } catch (err) {
            addLog(<ErrorLog message={err instanceof Error ? err.message : 'unknown error'} />);
            await terminate(1);
          }

          await terminate(0);
        }
      )
      .command(
        'rename <from> <to>',
        'rename a file and update all internal link references',
        (yargs) =>
          yargs
            .positional('from', {
              describe: 'the file to rename',
              type: 'string',
            })
            .positional('to', {
              describe: 'the new name for the file',
              type: 'string',
            })
            .demandOption(['from', 'to'])
            .option('force', {
              type: 'boolean',
              default: false,
              description: 'rename files and skip errors',
            })
            .epilog('example: `mintlify rename introduction.mdx overview.mdx`'),
        async ({ from, to, force }) => {
          const hasMintJson = await checkForMintJson();
          if (!hasMintJson) {
            await checkForDocsJson();
          }
          await renameFilesAndUpdateLinksInContent(from, to, force);
          await terminate(0);
        }
      )
      .command(
        'update',
        'update the CLI to the latest version',
        () => undefined,
        async () => {
          await update({ packageName });
          await terminate(0);
        }
      )
      .command(
        'upgrade',
        'upgrade mint.json file to docs.json (current format)',
        () => undefined,
        async () => {
          const hasMintJson = await checkForMintJson();
          if (!hasMintJson) {
            await checkForDocsJson();
          }
          await upgradeConfig();
        }
      )
      .command(
        'migrate-mdx',
        'migrate MDX OpenAPI endpoint pages to x-mint extensions and docs.json',
        () => undefined,
        async () => {
          await migrateMdx();
          await terminate(0);
        }
      )
      .command(
        ['version', 'v'],
        'display the current version of the CLI and client',
        () => undefined,
        async () => {
          const { cli, client } = getVersions();
          addLog(
            <Text>
              <Text bold color="green">
                cli version
              </Text>{' '}
              {cli}
            </Text>
          );
          addLog(
            <Text>
              <Text bold color="green">
                client version
              </Text>{' '}
              {client}
            </Text>
          );
        }
      )
      // Print the help menu when the user enters an invalid command.
      .strictCommands()
      .demandCommand(1, 'unknown command. see above for the list of supported commands.')

      // Alias option flags --help = -h, default --version = -v
      .alias('h', 'help')
      .alias('v', 'version')

      .parse()
  );
};
