import { getConfigPath } from '@mintlify/prebuild';
import { MintConfigUpdater } from '@mintlify/prebuild';
import {
  addLog,
  ErrorLog,
  getClientVersion,
  SuccessLog,
  InfoLog,
  SpinnerLog,
  removeLastLog,
  LOCAL_LINKED_CLI_VERSION,
} from '@mintlify/previewing';
import { upgradeToDocsConfig } from '@mintlify/validation';
import detect from 'detect-port';
import fse from 'fs-extra';
import fs from 'fs/promises';
import inquirer from 'inquirer';
import yaml from 'js-yaml';
import { exec, execSync } from 'node:child_process';
import { promisify } from 'node:util';
import path from 'path';
import type { ArgumentsCamelCase } from 'yargs';
import yargs from 'yargs';

import { CMD_EXEC_PATH } from './constants.js';

export const checkPort = async (argv: ArgumentsCamelCase): Promise<number | undefined> => {
  const initialPort = typeof argv.port === 'number' ? argv.port : 3000;
  if (initialPort === (await detect(initialPort))) return initialPort;

  for (let port = initialPort + 1; port < initialPort + 10; port++) {
    addLog(<InfoLog message={`port ${port - 1} is already in use. trying ${port} instead`} />);
    if (port === (await detect(port))) return port;
  }
};

export const checkNodeVersion = async () => {
  let nodeVersionString = process.version;
  if (nodeVersionString.charAt(0) === 'v') {
    nodeVersionString = nodeVersionString.slice(1);
  }
  const versionArr = nodeVersionString.split('.');
  const majorVersion = parseInt(versionArr[0]!, 10);

  if (majorVersion < 18) {
    addLog(
      <ErrorLog
        message={`mintlify requires a node version >= 18.0.0 (current version ${nodeVersionString}). try removing the mintlify package, upgrading node, reinstalling mintlify, and running again.`}
      />
    );
  }
};

export const checkForMintJson = async () => {
  return !!(await getConfigPath(CMD_EXEC_PATH, 'mint'));
};

export const checkForDocsJson = async () => {
  const docsJsonPath = path.join(CMD_EXEC_PATH, 'docs.json');
  if (!(await fse.pathExists(docsJsonPath))) {
    addLog(<InfoLog message="new docs.json file is available" />);
    const promptResult = await inquirer.prompt([
      {
        type: 'list',
        name: 'action',
        message: 'would you like to upgrade your mint.json to docs.json?',
        choices: [
          { name: 'upgrade (migrate from mint.json to docs.json)', value: 'upgrade' },
          { name: 'continue (use existing mint.json)', value: 'continue' },
        ],
      },
    ]);

    const { action } = promptResult;

    if (action === 'continue') {
      addLog(<InfoLog message="proceeding with the existing mint.json..." />);
    }

    if (action === 'upgrade') {
      addLog(<SpinnerLog message="upgrading docs.json..." />);
      await upgradeConfig();
    }
  }
};

export const upgradeConfig = async () => {
  try {
    const mintJsonPath = path.join(CMD_EXEC_PATH, 'mint.json');
    const docsJsonPath = path.join(CMD_EXEC_PATH, 'docs.json');
    const mintJsonFileContent = await fs.readFile(mintJsonPath, 'utf8');
    const validationResult = await MintConfigUpdater.validateConfigJsonString(mintJsonFileContent);
    const mintConfig = validationResult.data;
    const upgradedDocsConfig = upgradeToDocsConfig(mintConfig, {
      shouldUpgradeTheme: true,
    });
    await fs.writeFile(docsJsonPath, JSON.stringify(upgradedDocsConfig, null, 2));
    removeLastLog();
    addLog(<SuccessLog message="mint.json file has been upgraded to docs.json." />);
  } catch (err) {
    removeLastLog();
    addLog(<ErrorLog message={err instanceof Error ? err.message : 'an unknown error occurred'} />);
  }
};

export const getCliVersion = (): string | undefined => {
  const y = yargs();
  let version = undefined;
  y.showVersion((s) => {
    version = s;
    return false;
  });
  if (process.env.CLI_TEST_MODE === 'true') {
    return 'test-cli';
  }
  // when running `npm link` the version is 'unknown'
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (version === 'unknown') {
    version = LOCAL_LINKED_CLI_VERSION;
  }
  return version;
};

export const getVersions = (): {
  cli: string | undefined;
  client: string | undefined;
} => {
  const cli = getCliVersion();
  const client = getClientVersion().trim();
  return { cli, client };
};

export const getLatestCliVersion = (packageName: string) => {
  return execSync(`npm view ${packageName} version --silent`, {
    encoding: 'utf-8',
    stdio: ['pipe', 'pipe', 'pipe'],
  }).trim();
};

export const suppressConsoleWarnings = (): void => {
  // Ignore tailwind warnings and punycode deprecation warning
  const ignoredMessages = [
    'No utility classes were detected',
    'https://tailwindcss.com/docs/content-configuration',
    'DeprecationWarning',
  ];
  const originalConsoleError = console.error;
  console.error = (...args) => {
    const message = args.join(' ');
    if (ignoredMessages.some((ignoredMessage) => message.includes(ignoredMessage))) {
      return;
    }
    originalConsoleError.apply(console, args);
  };
  const originalConsoleWarn = console.warn;
  console.warn = (...args) => {
    const message = args.join(' ');
    if (ignoredMessages.some((ignoredMessage) => message.includes(ignoredMessage))) {
      return;
    }
    originalConsoleWarn.apply(console, args);
  };
};

export const readLocalOpenApiFile = async (
  filename: string
): Promise<Record<string, unknown> | undefined> => {
  const pathname = path.resolve(process.cwd(), filename);
  const file = await fs.readFile(pathname, 'utf-8');
  const document = yaml.load(file) as Record<string, unknown> | undefined;
  return document;
};

export const terminate = async (code: number) => {
  // Wait for the logs to be fully rendered before exiting
  await new Promise((resolve) => setTimeout(resolve, 50));
  process.exit(code);
};

export const execAsync = promisify(exec);

export const detectPackageManager = async ({ packageName }: { packageName: string }) => {
  try {
    const { stdout: packagePath } = await execAsync(`which ${packageName}`);
    if (packagePath.includes('pnpm')) {
      return 'pnpm';
    } else {
      return 'npm';
    }
  } catch (error) {
    return 'npm';
  }
};
