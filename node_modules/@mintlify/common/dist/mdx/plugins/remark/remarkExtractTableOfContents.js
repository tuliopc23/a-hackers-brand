import { slugifyWithCounter } from '@sindresorhus/slugify';
import { visit } from 'unist-util-visit';
import { slugify } from '../../../slugify.js';
import { createMdxJsxAttribute, getTableOfContentsTitle } from '../../lib/remark-utils.js';
import { HEADING_LEVELS } from './remarkComponentIds.js';
const HEADING_NAMES = ['h1', 'h2', 'h3', 'h4'];
const COMPONENTS_TO_EXCLUDE_HEADINGS = ['Accordion', 'AccordionGroup', 'Expandable', 'Update'];
export const remarkExtractTableOfContents = (mdxExtracts, pageMetadata) => {
    // slugifyWithCounter adds a counter (eg. slug, slug-2, slug-3) to the end of the slug if the header
    // already exists. No counter is added for the first occurence.
    const slugifyFn = slugifyWithCounter();
    return (tree) => {
        const contents = [];
        let hasTopLayer = false;
        // the key is the node in unist
        const tabContentMap = new Map();
        const excludedNodes = new Set();
        visit(tree, (node) => {
            if (node.type === 'mdxJsxFlowElement' &&
                node.name &&
                COMPONENTS_TO_EXCLUDE_HEADINGS.includes(node.name)) {
                visit(node, (childNode) => {
                    if (childNode !== node)
                        excludedNodes.add(childNode);
                });
            }
            if (node.type === 'mdxJsxFlowElement' && node.name === 'Tab') {
                const idAttr = node.attributes.find((attr) => 'name' in attr && attr.name === 'id');
                const titleAttr = node.attributes.find((attr) => 'name' in attr && attr.name === 'title');
                let tabId;
                if (idAttr && 'value' in idAttr && typeof idAttr.value === 'string') {
                    tabId = idAttr.value;
                }
                else if (titleAttr && 'value' in titleAttr && typeof titleAttr.value === 'string') {
                    tabId = slugify(titleAttr.value);
                }
                if (tabId) {
                    visit(node, (childNode) => {
                        tabContentMap.set(childNode, tabId);
                    });
                }
            }
        });
        visit(tree, (node) => {
            var _a, _b, _c, _d;
            if (excludedNodes.has(node))
                return;
            const currentTabId = tabContentMap.get(node);
            const isValidHeading = node.type === 'heading' && HEADING_LEVELS.includes(node.depth);
            const isValidMdxHeading = node.type === 'mdxJsxFlowElement' && HEADING_NAMES.includes((_a = node.name) !== null && _a !== void 0 ? _a : '');
            const isTransformedHeading = node.type === 'mdxJsxFlowElement' && node.name === 'Heading';
            const isValidUpdate = node.type === 'mdxJsxFlowElement' &&
                node.name === 'Update' &&
                node.attributes.some((attr) => 'name' in attr && attr.name === 'label');
            const hasIdAttribute = node.type === 'mdxJsxFlowElement' &&
                node.attributes.some((attr) => 'name' in attr && attr.name === 'id');
            const isCustomPageMode = (pageMetadata === null || pageMetadata === void 0 ? void 0 : pageMetadata.mode) === 'custom';
            if (!isValidHeading && !isValidMdxHeading && !isTransformedHeading && !isValidUpdate) {
                return;
            }
            if (isCustomPageMode && (isValidHeading || isValidMdxHeading))
                return;
            let level;
            if ('name' in node && node.name === 'Update') {
                level = 1;
                // @ts-expect-error we're assigning to depth despite the node not containing depth in the type
                node.depth = 1;
            }
            else if ('depth' in node) {
                level = node.depth;
            }
            else if ('name' in node && node.name === 'Heading') {
                const levelAttr = node.attributes.find((attr) => 'name' in attr && attr.name === 'level');
                if (levelAttr && 'value' in levelAttr && typeof levelAttr.value === 'number') {
                    level = levelAttr.value;
                }
            }
            else if ('name' in node && ((_b = node.name) === null || _b === void 0 ? void 0 : _b[1])) {
                const num = Number(node.name[1]);
                level = !isNaN(num) ? num : undefined;
            }
            const title = getTableOfContentsTitle(node);
            let slug;
            if ('name' in node && node.name === 'Heading') {
                const idAttr = node.attributes.find((attr) => 'name' in attr && attr.name === 'id');
                if (idAttr && 'value' in idAttr && typeof idAttr.value === 'string') {
                    slug = idAttr.value;
                }
                else {
                    slug = slugify(title, slugifyFn);
                }
            }
            else {
                slug = slugify(title, slugifyFn);
            }
            let mdxJsxAttributes;
            if ('name' in node && node.name === 'Update') {
                mdxJsxAttributes = [...node.attributes, createMdxJsxAttribute('id', slug)];
            }
            else if ('name' in node && node.name === 'Heading') {
                mdxJsxAttributes = node.attributes;
            }
            else if (level !== undefined && !hasIdAttribute) {
                mdxJsxAttributes = [
                    createMdxJsxAttribute('level', level),
                    createMdxJsxAttribute('id', slug),
                ];
                if (isValidMdxHeading && node.attributes.length > 0) {
                    mdxJsxAttributes.push(...node.attributes);
                }
            }
            // @ts-expect-error we're assigning over 'attributes' if it doesn't exist
            node.attributes = mdxJsxAttributes;
            node.type = 'mdxJsxFlowElement';
            // @ts-expect-error we're assigning over 'name' if it doesn't exist
            node.name = node.name === 'Update' ? 'Update' : 'Heading';
            // @ts-expect-error we've already written to 'depth' and so this should be safe
            const depth = node.depth;
            if (level !== undefined && Number(level) <= 2) {
                hasTopLayer = true;
                contents.push({ title, slug, depth, children: [], tabId: currentTabId });
            }
            else {
                // Account if there is no first layer
                let arrToPushInto = contents;
                if (hasTopLayer) {
                    arrToPushInto = (_d = (_c = contents.at(-1)) === null || _c === void 0 ? void 0 : _c.children) !== null && _d !== void 0 ? _d : [];
                }
                arrToPushInto.push({ title, slug, depth, children: [], tabId: currentTabId });
            }
        });
        if (mdxExtracts) {
            mdxExtracts.tableOfContents = contents;
        }
    };
};
