import { slugifyWithCounter } from '@sindresorhus/slugify';
import { visit } from 'unist-util-visit';
import { slugify } from '../../../slugify.js';
import { createMdxJsxAttribute } from '../../lib/remark-utils.js';
import { getTableOfContentsTitle } from '../../lib/remark-utils.js';
export const HEADING_LEVELS = [1, 2, 3, 4];
export const remarkComponentIds = () => (tree) => {
    const slugifyFn = slugifyWithCounter();
    const tabSlugifyFn = slugifyWithCounter();
    visit(tree, 'heading', (node) => {
        if (HEADING_LEVELS.includes(node.depth)) {
            const title = getTableOfContentsTitle(node);
            const slug = slugify(title, slugifyFn);
            const mdxJsxAttributes = [
                createMdxJsxAttribute('level', node.depth),
                createMdxJsxAttribute('id', slug),
            ];
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            node.attributes = mdxJsxAttributes;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            node.type = 'mdxJsxFlowElement';
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            node.name = 'Heading';
        }
    });
    const tabSlugs = new Map();
    const precomputeTabSlugs = (node) => {
        var _a;
        if (node.type === 'mdxJsxFlowElement' && node.name === 'Tab') {
            const title = (_a = node.attributes.find((attr) => 'name' in attr && attr.name === 'title')) === null || _a === void 0 ? void 0 : _a.value;
            if (title && typeof title === 'string') {
                const slug = slugify(title, tabSlugifyFn);
                tabSlugs.set(node, slug);
            }
        }
        if ('children' in node) {
            for (const child of node.children) {
                precomputeTabSlugs(child);
            }
        }
    };
    const processTabsRecursively = (node) => {
        if (node.type === 'mdxJsxFlowElement' && node.name === 'Tab') {
            const slug = tabSlugs.get(node);
            if (!slug)
                return;
            node.attributes.push(createMdxJsxAttribute('id', slug));
            const childTabIds = [];
            for (const child of node.children) {
                const childIds = collectDirectChildTabs(child);
                childTabIds.push(...childIds);
            }
            if (childTabIds.length > 0) {
                try {
                    node.attributes.push(createMdxJsxAttribute('data-child-tab-ids', JSON.stringify(childTabIds)));
                }
                catch (_a) { }
            }
            for (const child of node.children) {
                processTabsRecursively(child);
            }
        }
        else if ('children' in node) {
            for (const child of node.children) {
                processTabsRecursively(child);
            }
        }
    };
    const collectDirectChildTabs = (node) => {
        const childIds = [];
        if (node.type === 'mdxJsxFlowElement' && node.name === 'Tab') {
            const slug = tabSlugs.get(node);
            if (slug) {
                childIds.push(slug);
            }
        }
        else if ('children' in node) {
            for (const child of node.children) {
                childIds.push(...collectDirectChildTabs(child));
            }
        }
        return childIds;
    };
    precomputeTabSlugs(tree);
    processTabsRecursively(tree);
};
