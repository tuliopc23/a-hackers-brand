import { jsx, toJs } from 'estree-util-to-js';
import { visit, EXIT } from 'unist-util-visit';
import { nodeIncludesExport } from '../nodeIncludesExport.js';
import { addExportPrefix } from './addExportPrefix.js';
/**
 * Finds the export in the tree and returns the content of the export
 * @param exportName the name of the export we want to find
 * @param tree the content we are looking for the export in
 * @returns the export
 */
export const findExport = (exportName, tree, renamedExportName) => {
    let value;
    visit(tree, nodeIncludesExport, (node) => {
        for (const bodyChild of node.data.estree.body) {
            // handle `export default ...`
            if (bodyChild.type === 'ExportDefaultDeclaration') {
                if (exportName === 'default') {
                    const isolatedExport = structuredClone(node);
                    isolatedExport.data.estree.body = [bodyChild];
                    // handle renaming for default exports
                    if (renamedExportName && bodyChild.declaration.type === 'Identifier') {
                        bodyChild.declaration.name = renamedExportName;
                    }
                    value = toJs(isolatedExport.data.estree, { handlers: jsx }).value;
                    return EXIT;
                }
                continue;
            }
            // handle `export { name }`
            if (bodyChild.type === 'ExportNamedDeclaration' && bodyChild.specifiers.length > 0) {
                for (const specifier of bodyChild.specifiers) {
                    if (specifier.exported.name === exportName) {
                        const localName = specifier.local.name;
                        const originalDeclaration = findDeclarationInTree(localName, node);
                        if (originalDeclaration) {
                            const isolatedExport = structuredClone(originalDeclaration);
                            if (renamedExportName) {
                                renameInDeclaration(isolatedExport, localName, renamedExportName);
                            }
                            const wrappedNode = structuredClone(node);
                            wrappedNode.data.estree.body = [isolatedExport];
                            value = toJs(wrappedNode.data.estree, { handlers: jsx }).value;
                            return EXIT;
                        }
                    }
                }
                continue;
            }
            // handle `export const/let/var/function/class ...`
            if (bodyChild.type === 'ExportNamedDeclaration' &&
                bodyChild.declaration &&
                bodyChild.declaration.type === 'VariableDeclaration') {
                for (const declaration of bodyChild.declaration.declarations) {
                    if (declaration.id.type !== 'Identifier')
                        continue;
                    if (declaration.id.name === exportName) {
                        // renaming for: import { Name as RenamedName } from './source';
                        if (renamedExportName) {
                            declaration.id.name = renamedExportName;
                        }
                        // sometimes when more than one exports are defined next to each other, the body includes multiple exports so we isolate the export we are looking for.
                        const isolatedExport = structuredClone(node);
                        isolatedExport.data.estree.body = [bodyChild];
                        value = toJs(isolatedExport.data.estree, { handlers: jsx }).value;
                        return EXIT;
                    }
                }
            }
            // handle `export function/class ...`
            if (bodyChild.type === 'ExportNamedDeclaration' && bodyChild.declaration) {
                if ((bodyChild.declaration.type === 'FunctionDeclaration' ||
                    bodyChild.declaration.type === 'ClassDeclaration') &&
                    bodyChild.declaration.id &&
                    bodyChild.declaration.id.name === exportName) {
                    if (renamedExportName) {
                        bodyChild.declaration.id.name = renamedExportName;
                    }
                    const isolatedExport = structuredClone(node);
                    isolatedExport.data.estree.body = [bodyChild];
                    value = toJs(isolatedExport.data.estree, { handlers: jsx }).value;
                    return EXIT;
                }
            }
        }
    });
    return addExportPrefix(value);
};
function findDeclarationInTree(name, node) {
    var _a, _b;
    for (const bodyChild of node.data.estree.body) {
        if (bodyChild.type === 'VariableDeclaration') {
            for (const declaration of bodyChild.declarations) {
                if (declaration.id.type === 'Identifier' && declaration.id.name === name) {
                    return bodyChild;
                }
            }
        }
        else if (bodyChild.type === 'FunctionDeclaration' && ((_a = bodyChild.id) === null || _a === void 0 ? void 0 : _a.name) === name) {
            return bodyChild;
        }
        else if (bodyChild.type === 'ClassDeclaration' && ((_b = bodyChild.id) === null || _b === void 0 ? void 0 : _b.name) === name) {
            return bodyChild;
        }
    }
    return null;
}
function renameInDeclaration(declaration, oldName, newName) {
    var _a, _b;
    if (declaration.type === 'VariableDeclaration') {
        for (const variableDeclarator of declaration.declarations) {
            if (variableDeclarator.id.type === 'Identifier' && variableDeclarator.id.name === oldName) {
                variableDeclarator.id.name = newName;
            }
        }
    }
    else if (declaration.type === 'FunctionDeclaration' && ((_a = declaration.id) === null || _a === void 0 ? void 0 : _a.name) === oldName) {
        declaration.id.name = newName;
    }
    else if (declaration.type === 'ClassDeclaration' && ((_b = declaration.id) === null || _b === void 0 ? void 0 : _b.name) === oldName) {
        declaration.id.name = newName;
    }
}
