var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { serialize } from '@mintlify/mdx';
import { getTailwindSelectors } from '../../css/tailwind.js';
import { getMDXOptions, remarkMdxRemoveJs, remarkExpandContent, remarkSplitCodeGroup, remarkSplitTabs, remarkValidateSteps, remarkValidateTabs, } from '../../index.js';
import { createSnippetTreeMap } from './getMdx/snippets.js';
export function getMdx(_a) {
    return __awaiter(this, arguments, void 0, function* ({ path, content, metadata, snippets, subdomain, codeStyling, tailwindSelectors = undefined, pageType = 'default', }) {
        if (!tailwindSelectors)
            tailwindSelectors = yield getTailwindSelectors({ content });
        const snippetTreeMap = yield createSnippetTreeMap(snippets);
        const mdxOptionsData = {
            subdomain,
            snippetTreeMap,
            pageMetadata: metadata,
            codeStyling,
            tailwindSelectors,
        };
        let mdxExtracts = {};
        let plugins = [remarkValidateSteps, remarkValidateTabs];
        if (pageType === 'pdf') {
            plugins = [...plugins, remarkExpandContent, remarkSplitCodeGroup, remarkSplitTabs];
        }
        const mdxOptions = getMDXOptions({ data: mdxOptionsData, remarkPlugins: plugins, mdxExtracts });
        const mdxOptionsNoJs = getMDXOptions({
            data: mdxOptionsData,
            remarkPlugins: [remarkMdxRemoveJs, ...plugins],
        });
        const scope = {
            codeStyling,
            pageMetadata: metadata,
        };
        const { mdxSource, mdxSourceWithNoJs } = yield compileMdx(content, scope, mdxOptions, mdxOptionsNoJs, codeStyling, path);
        const originalMdxExtracts = structuredClone(mdxExtracts);
        let panelMdxSource;
        let panelMdxSourceWithNoJs;
        if (mdxExtracts.panel && mdxExtracts.panel.content) {
            const panelContent = mdxExtracts.panel.content;
            const compiledMdx = yield compileMdx(panelContent, scope, mdxOptions, mdxOptionsNoJs, codeStyling, path);
            panelMdxSource = compiledMdx.mdxSource;
            panelMdxSourceWithNoJs = compiledMdx.mdxSourceWithNoJs;
            // serializing mdx content with the panel content will remove the original mdxExtracts
            // so we need to restore the original mdxExtracts
            mdxExtracts = Object.assign(Object.assign({}, originalMdxExtracts), { codeExamples: mdxExtracts.codeExamples });
        }
        return {
            mdxExtracts,
            mdxSource,
            mdxSourceWithNoJs,
            panelMdxSource,
            panelMdxSourceWithNoJs,
        };
    });
}
function compileMdx(content, scope, mdxOptions, mdxOptionsNoJs, codeStyling, path) {
    return __awaiter(this, void 0, void 0, function* () {
        const mdxSource = yield getCompiledMdxWithFallback(content, scope, mdxOptions, codeStyling, path);
        const mdxSourceWithNoJs = yield getCompiledMdxWithFallback(content, scope, mdxOptionsNoJs, codeStyling, path);
        return { mdxSource, mdxSourceWithNoJs };
    });
}
function getCompiledMdxWithFallback(source, scope, mdxOptions, codeStyling, path) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield serialize({
                source,
                scope,
                mdxOptions,
                syntaxHighlightingOptions: {
                    codeStyling,
                },
            });
            if ('error' in result) {
                throw result.error;
            }
            result.scope = Object.assign(Object.assign({}, result.scope), { config: {} });
            return result;
        }
        catch (err) {
            if (path)
                console.log(`‚ö†Ô∏è Warning: MDX failed to parse page ${path}: `, err);
            // placeholder content for when there is a syntax error.
            const fallbackResult = yield serialize({
                source: 'üöß A parsing error occured. Please contact the owner of this website. They can use the Mintlify CLI to test this website locally and see the errors that occur.',
                scope,
                mdxOptions,
            });
            if ('error' in fallbackResult) {
                throw fallbackResult.error;
            }
            fallbackResult.scope = Object.assign(Object.assign({}, fallbackResult.scope), { config: {} });
            return fallbackResult;
        }
    });
}
export { createSnippetTreeMap };
