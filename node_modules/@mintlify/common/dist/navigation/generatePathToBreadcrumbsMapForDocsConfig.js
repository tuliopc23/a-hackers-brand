import { divisions } from '@mintlify/validation';
const MAX_RECURSION_DEPTH = 100;
export function generatePathToBreadcrumbsMapForDocsConfig(navigation) {
    const pathToBreadcrumbs = new Map();
    generatePathToBreadcrumbsMapForDocsConfigRecursive(navigation, pathToBreadcrumbs, []);
    return pathToBreadcrumbs;
}
function generatePathToBreadcrumbsMapForDocsConfigRecursive(nav, map, currentBreadcrumbs = []) {
    if ('pages' in nav) {
        generatePathToBreadcrumbsMapForPagesRecursive(nav.pages, currentBreadcrumbs, map);
    }
    for (const key of [...divisions, 'groups']) {
        if (key in nav) {
            const items = nav[key];
            if (!Array.isArray(items)) {
                continue;
            }
            for (const item of items) {
                let divisionTitle = '';
                // We purposely exclude `versions` and `languages` here to avoid
                // cluttering the breadcrumbs unneccessarily.
                if (key === 'dropdowns' && 'dropdown' in item && typeof item.dropdown === 'string') {
                    divisionTitle = item.dropdown;
                }
                else if (key === 'tabs' && 'tab' in item && typeof item.tab === 'string') {
                    divisionTitle = item.tab;
                }
                else if (key === 'anchors' && 'anchor' in item && typeof item.anchor === 'string') {
                    divisionTitle = item.anchor;
                }
                else if (key === 'groups' && 'group' in item && typeof item.group === 'string') {
                    divisionTitle = item.group;
                }
                const newBreadcrumbs = divisionTitle
                    ? [...currentBreadcrumbs, divisionTitle]
                    : currentBreadcrumbs;
                generatePathToBreadcrumbsMapForDocsConfigRecursive(item, map, newBreadcrumbs);
            }
        }
    }
}
export function generatePathToBreadcrumbsMapForPagesRecursive(pages, currentBreadcrumbs, map, depth = 0) {
    if (depth >= MAX_RECURSION_DEPTH)
        return;
    for (const entry of pages) {
        if (typeof entry === 'object' && 'group' in entry && typeof entry.group === 'string') {
            currentBreadcrumbs.push(entry.group);
            if ('pages' in entry && Array.isArray(entry.pages)) {
                generatePathToBreadcrumbsMapForPagesRecursive(entry.pages, currentBreadcrumbs, map, depth + 1);
            }
            currentBreadcrumbs.pop();
        }
        else {
            const nonEmptyBreadcrumbs = currentBreadcrumbs.filter((crumb) => !!crumb.trim());
            map.set(entry, [...nonEmptyBreadcrumbs]);
        }
    }
}
