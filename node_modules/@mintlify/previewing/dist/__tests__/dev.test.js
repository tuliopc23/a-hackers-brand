import { prebuild } from '@mintlify/prebuild';
import fse from 'fs-extra';
import isOnline from 'is-online';
import { mockProcessExit } from 'vitest-mock-process';
import { dev } from '../index.js';
import { run } from '../local-preview/run.js';
import { silentUpdateClient } from '../local-preview/update.js';
import * as logs from '../logging-state.js';
const originalChdir = process.chdir;
vi.mock('fs-extra', () => {
    const mocks = {
        ensureDir: vi.fn().mockResolvedValue(undefined),
        pathExists: vi.fn().mockResolvedValue(true),
        readFileSync: vi.fn().mockReturnValue('0.0.100'),
        emptyDirSync: vi.fn().mockResolvedValue(undefined),
    };
    return {
        ...mocks,
        default: mocks,
    };
});
vi.mock('../local-preview/update.js', () => ({
    silentUpdateClient: vi.fn().mockResolvedValue({ needsUpdate: false, error: undefined }),
}));
vi.mock('is-online', () => ({
    default: vi.fn().mockResolvedValue(true),
}));
vi.mock('@mintlify/prebuild', () => ({
    prebuild: vi.fn().mockResolvedValue(undefined),
}));
vi.mock('../local-preview/run.js', () => ({
    run: vi.fn().mockResolvedValue(undefined),
}));
vi.mock('../util.js', () => {
    return {
        maybeFixMissingWindowsEnvVar: vi.fn(),
    };
});
const prebuildMock = vi.mocked(prebuild);
const runMock = vi.mocked(run);
const silentUpdateClientMock = vi.mocked(silentUpdateClient);
const defaultYargs = {
    _: [],
    $0: '',
    packageName: 'mintlify',
    cliVersion: '1.0.0',
};
const addLogSpy = vi.spyOn(logs, 'addLog');
const processExitMock = mockProcessExit();
describe('dev', () => {
    beforeEach(() => {
        process.chdir = vi.fn();
        vi.clearAllMocks();
    });
    afterEach(() => {
        process.chdir = originalChdir;
    });
    it('happy path', async () => {
        await dev(defaultYargs);
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { message: 'preparing local preview...' } }));
        expect(silentUpdateClientMock).toHaveBeenCalled();
        expect(prebuildMock).toHaveBeenCalled();
        expect(runMock).toHaveBeenCalled();
    });
    it('prebuild fails', async () => {
        const errorText = 'Some OpenAPI or docs.json schema error';
        prebuildMock.mockRejectedValueOnce(new Error(errorText));
        await dev(defaultYargs);
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { message: 'preparing local preview...' } }));
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { message: errorText } }));
        expect(processExitMock).toHaveBeenCalledWith(1);
    });
    it('fails if no existing client version and no internet', async () => {
        vi.mocked(isOnline).mockResolvedValueOnce(false);
        vi.mocked(fse.pathExists).mockResolvedValueOnce();
        await dev(defaultYargs).catch(() => { });
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({
            props: { message: 'running mintlify dev after updating requires an internet connection.' },
        }));
        expect(processExitMock).toHaveBeenCalledWith(1);
    });
    it('fails if no existing client version and no internet - mint command', async () => {
        vi.mocked(isOnline).mockResolvedValueOnce(false);
        vi.mocked(fse.pathExists).mockResolvedValueOnce();
        await dev({ ...defaultYargs, packageName: 'mint' }).catch(() => { });
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({
            props: { message: 'running mint dev after updating requires an internet connection.' },
        }));
        expect(processExitMock).toHaveBeenCalledWith(1);
    });
});
