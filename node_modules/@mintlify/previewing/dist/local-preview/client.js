import fse from 'fs-extra';
import got from 'got';
import isOnline from 'is-online';
import { pipeline } from 'node:stream/promises';
import tar from 'tar';
import yaml from 'js-yaml';
import { DOT_MINTLIFY, DOT_MINTLIFY_LAST, VERSION_PATH, TAR_PATH, TARGET_MINT_VERSION_URL, MINT_VERSION_MAP_URL, } from '../constants.js';
import { restoreMintlifyLast, getTarUrl } from '../util.js';
export const getLatestClientVersion = async () => {
    const hasInternet = await isOnline();
    if (!hasInternet) {
        return undefined;
    }
    try {
        const response = await got(TARGET_MINT_VERSION_URL);
        return response.body;
    }
    catch (error) {
        return undefined;
    }
};
export const downloadTargetMint = async ({ targetVersion, existingVersion, }) => {
    if (fse.existsSync(DOT_MINTLIFY)) {
        fse.moveSync(DOT_MINTLIFY, DOT_MINTLIFY_LAST, { overwrite: true });
    }
    fse.ensureDirSync(DOT_MINTLIFY);
    const tarUrl = getTarUrl(targetVersion);
    let currentVersion = targetVersion.trim();
    try {
        await pipeline(got.stream(tarUrl), fse.createWriteStream(TAR_PATH));
    }
    catch (error) {
        if (existingVersion) {
            currentVersion = existingVersion;
            restoreMintlifyLast();
            return;
        }
        else {
            throw new Error(`failed to install mintlify framework version ${currentVersion}, ${error}`);
        }
    }
    try {
        tar.x({
            sync: true,
            file: TAR_PATH,
            cwd: DOT_MINTLIFY,
            onwarn: (_code, message, _data) => {
                throw new Error(message);
            },
        });
    }
    catch (error) {
        if (existingVersion) {
            currentVersion = existingVersion;
            restoreMintlifyLast();
            return;
        }
        else {
            throw new Error(`failed to extract mintlify framework version ${currentVersion}, ${error}`);
        }
    }
    fse.removeSync(TAR_PATH);
    if (fse.existsSync(DOT_MINTLIFY_LAST)) {
        fse.removeSync(DOT_MINTLIFY_LAST);
    }
    fse.writeFileSync(VERSION_PATH, currentVersion);
};
export const getVersionMap = async () => {
    try {
        const response = await got(MINT_VERSION_MAP_URL);
        return response.body;
    }
    catch (error) {
        return undefined;
    }
};
export const getCompatibleClientVersion = async ({ cliVersion }) => {
    const versionMap = await getVersionMap();
    if (!versionMap) {
        return undefined;
    }
    const versionMapObj = yaml.load(versionMap);
    if (cliVersion && versionMapObj[cliVersion]) {
        const { max } = versionMapObj[cliVersion];
        if (max !== "") {
            return max;
        }
        else {
            return "latest";
        }
    }
    return undefined;
};
export const tryDownloadTargetMint = async ({ targetVersion, existingVersion }) => {
    let error;
    try {
        await downloadTargetMint({ targetVersion, existingVersion });
    }
    catch (err) {
        error = err instanceof Error ? err.message : 'unknown error';
    }
    return error;
};
